const Artifact = require('../models/Artifact');
const Snapshot = require('../models/Snapshot');

async function exportJson(snapshotId) {
    const snapshot = await Snapshot.findById(snapshotId);
    if (!snapshot) throw new Error('Snapshot not found');

    const data = {
        metadata: {
            databaseName: snapshot.databaseName,
            databaseType: snapshot.dbType,
            connectionName: snapshot.connectionName,
            exportedAt: new Date().toISOString(),
            tableCount: snapshot.tableCount,
            totalRows: snapshot.totalRows,
            extractedAt: snapshot.extractedAt,
            qualityAnalyzedAt: snapshot.qualityAnalyzedAt,
            aiGeneratedAt: snapshot.aiGeneratedAt,
        },
        tables: snapshot.tables.map((t) => ({
            name: t.name,
            rowCount: t.rowCount,
            sizeBytes: t.sizeBytes,
            lastModified: t.lastModified,
            qualityScore: t.qualityScore,
            qualityFlags: t.qualityFlags,
            aiSummary: t.aiSummary,
            aiUsageRecommendations: t.aiUsageRecommendations,
            aiSampleQueries: t.aiSampleQueries,
            referencedBy: t.referencedBy,
            columns: t.columns.map((c) => ({
                name: c.name,
                dataType: c.dataType,
                isNullable: c.isNullable,
                defaultValue: c.defaultValue,
                isPrimaryKey: c.isPrimaryKey,
                isForeignKey: c.isForeignKey,
                isUnique: c.isUnique,
                isIndexed: c.isIndexed,
                foreignKeyRef: c.foreignKeyRef,
                aiDescription: c.aiDescription,
                quality: c.quality,
            })),
        })),
    };

    const content = JSON.stringify(data, null, 2);
    const filename = `${snapshot.connectionName.replace(/\s+/g, '_')}_${snapshot.databaseName}_${Date.now()}.json`;
    const sizeBytes = Buffer.byteLength(content, 'utf8');

    const artifact = await Artifact.create({
        snapshotId,
        connectionName: snapshot.connectionName,
        format: 'json',
        content,
        filename,
        sizeBytes,
    });

    return { artifact, content, filename };
}


async function exportMarkdown(snapshotId) {
    const snapshot = await Snapshot.findById(snapshotId);
    if (!snapshot) throw new Error('Snapshot not found');

    const lines = [];
    const now = new Date().toISOString().split('T')[0];

    lines.push(`# Data Dictionary â€” ${snapshot.databaseName}`);
    lines.push(`\n> Generated by DataLens AI on ${now} | Connection: ${snapshot.connectionName} | Type: ${snapshot.dbType.toUpperCase()}`);
    lines.push('\n---\n');

    lines.push('## Overview\n');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| Database | ${snapshot.databaseName} |`);
    lines.push(`| Type | ${snapshot.dbType.toUpperCase()} |`);
    lines.push(`| Table Count | ${snapshot.tableCount} |`);
    lines.push(`| Total Rows | ${(snapshot.totalRows || 0).toLocaleString()} |`);
    lines.push(`| Extracted At | ${snapshot.extractedAt ? new Date(snapshot.extractedAt).toLocaleString() : 'N/A'} |`);
    lines.push(`| AI Generated At | ${snapshot.aiGeneratedAt ? new Date(snapshot.aiGeneratedAt).toLocaleString() : 'Pending'} |`);

    lines.push('\n---\n');
    lines.push('## Table of Contents\n');
    for (const table of snapshot.tables) {
        const anchor = table.name.toLowerCase().replace(/[^a-z0-9]/g, '-');
        lines.push(`- [${table.name}](#${anchor})`);
    }

    for (const table of snapshot.tables) {
        const anchor = table.name.toLowerCase().replace(/[^a-z0-9]/g, '-');
        lines.push(`\n---\n`);
        lines.push(`## ${table.name} {#${anchor}}\n`);

        const score = table.qualityScore ?? 'N/A';
        const scoreLabel = score >= 80 ? 'ðŸŸ¢' : score >= 60 ? 'ðŸŸ¡' : 'ðŸ”´';
        lines.push(`**Quality Score:** ${scoreLabel} ${score}/100\n`);

        if (table.aiSummary) {
            lines.push('### Business Summary\n');
            lines.push(table.aiSummary);
        }

        if (table.aiUsageRecommendations) {
            lines.push('\n### Usage Recommendations\n');
            lines.push(table.aiUsageRecommendations);
        }

        lines.push('\n### Statistics\n');
        lines.push('| Metric | Value |');
        lines.push('|--------|-------|');
        lines.push(`| Row Count | ${(table.rowCount || 0).toLocaleString()} |`);
        lines.push(`| Size | ${formatBytes(table.sizeBytes)} |`);
        lines.push(`| Quality Score | ${score}/100 |`);
        if (table.qualityFlags && table.qualityFlags.length > 0) {
            lines.push(`| Quality Flags | ${table.qualityFlags.join(', ')} |`);
        }
        if (table.referencedBy && table.referencedBy.length > 0) {
            lines.push(`| Referenced By | ${table.referencedBy.map((r) => `${r.table}.${r.column}`).join(', ')} |`);
        }

        lines.push('\n### Columns\n');
        lines.push('| Column | Type | Nullable | Keys | AI Description |');
        lines.push('|--------|------|----------|------|----------------|');
        for (const col of table.columns || []) {
            const keys = [];
            if (col.isPrimaryKey) keys.push('PK');
            if (col.isForeignKey) keys.push(`FK â†’ ${col.foreignKeyRef?.table}.${col.foreignKeyRef?.column}`);
            if (col.isUnique) keys.push('UNIQUE');
            if (col.isIndexed) keys.push('INDEX');
            const nullable = col.isNullable ? 'YES' : 'NO';
            const desc = (col.aiDescription || '').replace(/\|/g, '\\|');
            lines.push(`| ${col.name} | ${col.dataType} | ${nullable} | ${keys.join(', ')} | ${desc} |`);
        }

        const colsWithQuality = (table.columns || []).filter((c) => c.quality && c.quality.completeness !== undefined);
        if (colsWithQuality.length > 0) {
            lines.push('\n### Data Quality\n');
            lines.push('| Column | Completeness | Null Count | Distinct Count |');
            lines.push('|--------|-------------|------------|----------------|');
            for (const col of colsWithQuality) {
                const completeness = col.quality.completeness !== undefined ? `${col.quality.completeness.toFixed(1)}%` : 'N/A';
                lines.push(`| ${col.name} | ${completeness} | ${col.quality.nullCount ?? 'N/A'} | ${col.quality.distinctCount ?? 'N/A'} |`);
            }

            const numericCols = colsWithQuality.filter(
                (c) => c.quality.min !== undefined && c.quality.avg !== undefined
            );
            if (numericCols.length > 0) {
                lines.push('\n#### Numeric Statistics\n');
                lines.push('| Column | Min | Avg | Max | P50 | P95 | Outliers | Skewness |');
                lines.push('|--------|-----|-----|-----|-----|-----|----------|----------|');
                for (const col of numericCols) {
                    const q = col.quality;
                    const fmt = (v) => (v !== undefined && v !== null ? Number(v).toFixed(2) : 'N/A');
                    lines.push(
                        `| ${col.name} | ${fmt(q.min)} | ${fmt(q.avg)} | ${fmt(q.max)} | ${fmt(q.p50)} | ${fmt(q.p95)} | ${q.outlierCount ?? 'N/A'} | ${fmt(q.skewness)} |`
                    );
                }
            }
        }

        if (table.aiSampleQueries && table.aiSampleQueries.length > 0) {
            lines.push('\n### Sample Queries\n');
            for (const query of table.aiSampleQueries) {
                lines.push('```sql');
                lines.push(query);
                lines.push('```\n');
            }
        }

        if (table.qualityFlags && table.qualityFlags.length > 0) {
            lines.push('\n### âš ï¸ Quality Warnings\n');
            for (const flag of table.qualityFlags) {
                lines.push(`- ${flag}`);
            }
        }
    }

    const content = lines.join('\n');
    const filename = `${snapshot.connectionName.replace(/\s+/g, '_')}_${snapshot.databaseName}_${Date.now()}.md`;
    const sizeBytes = Buffer.byteLength(content, 'utf8');

    const artifact = await Artifact.create({
        snapshotId,
        connectionName: snapshot.connectionName,
        format: 'markdown',
        content,
        filename,
        sizeBytes,
    });

    return { artifact, content, filename };
}

function formatBytes(bytes) {
    if (!bytes) return '0 B';
    const units = ['B', 'KB', 'MB', 'GB'];
    let i = 0;
    let size = bytes;
    while (size >= 1024 && i < units.length - 1) {
        size /= 1024;
        i++;
    }
    return `${size.toFixed(1)} ${units[i]}`;
}

module.exports = { exportJson, exportMarkdown };
